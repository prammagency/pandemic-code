import os
import json
from pathlib import Path

def explain_directory_content(base_path, include_files=True, max_depth=None, depth=0):
    """
    Recursively list and explain the contents of a directory.
    
    Args:
        base_path: The base directory path to explore
        include_files: Whether to include files in the output
        max_depth: Maximum depth to explore (None for unlimited)
        depth: Current depth (used for recursion)
    
    Returns:
        A dictionary containing the structure and explanation
    """
    if max_depth is not None and depth > max_depth:
        return {"type": "directory_truncated", "note": "Maximum depth reached"}
    
    result = {}
    
    try:
        # Get all entries in the directory
        entries = os.listdir(base_path)
        
        # Process directories first
        directories = []
        files = []
        
        for entry in entries:
            entry_path = os.path.join(base_path, entry)
            
            if os.path.isdir(entry_path):
                directories.append(entry)
            elif include_files:
                files.append(entry)
        
        # Add directories to result
        for directory in sorted(directories):
            dir_path = os.path.join(base_path, directory)
            result[directory] = explain_directory_content(dir_path, include_files, max_depth, depth + 1)
            result[directory]["type"] = "directory"
            result[directory]["path"] = dir_path
        
        # Add files to result
        if include_files:
            for file in sorted(files):
                file_path = os.path.join(base_path, file)
                extension = os.path.splitext(file)[1].lower()
                
                result[file] = {
                    "type": "file",
                    "path": file_path,
                    "extension": extension
                }
    
    except Exception as e:
        result["error"] = str(e)
    
    return result

def add_directory_explanations(structure, path_prefix=""):
    """Add explanations to directory structure based on path and content."""
    
    explanations = {
        "Dreambot Api Docs- Classes_Enums": "Contains extracted classes, enums, interfaces, and logic definitions from the DreamBot API documentation. This serves as the reference for mapping PSC actions to underlying DreamBot API calls.",
        "enriched_code - Pandemics code": "Contains actual internal code from Pandemic Script Creator showing the exact JSON output format. These files were downloaded directly from the software and reveal the structure of how PSC writes its code.",
        "Pandemic coding docs - original - Not Cleaned": "Contains raw documentation from Pandemic Script Creator before cleaning and processing.",
        "cleaned_docs - pandemic URL docs": "Contains processed and cleaned documentation from the PSC website, providing clear explanations of actions, usage examples, and details about PSC's JSON domain-specific language.",
        "psc-dreambot-integration": "Main project folder containing our standardization framework.",
        "libraries": "Contains all standardized libraries we've created, including action hierarchy, filter types, control flow, and property values libraries as well as game-specific libraries for monsters, equipment, and locations.",
        "scripts": "Contains our Python tools for analyzing, standardizing, validating, and generating code from PSC JSON files.",
        "mapping": "Contains the ActionID_CategoryMap.json that links PSC actions to their categories.",
        "data": "Contains directories for raw PSC JSON files, organized files, standardized files, and analysis reports.",
        "raw": "Original PSC JSON files before processing.",
        "organized": "PSC JSON files organized by category.",
        "standardized": "PSC JSON files that have been standardized according to our reference libraries.",
        "analysis": "Analysis reports generated by our PSC Standardizer.",
        "validation": "Validation reports for standardized PSC files.",
        "output": "Contains generated DreamBot Java code and other output files."
    }
    
    for name, content in structure.items():
        if isinstance(content, dict):  # Check if content is a dictionary
            if content.get("type") == "directory":
                current_path = os.path.join(path_prefix, name)
                
                # Add explanation if available
                if name in explanations:
                    content["explanation"] = explanations[name]
                elif current_path in explanations:
                    content["explanation"] = explanations[current_path]
                
                # Process subdirectories - only if they're dictionaries
                add_directory_explanations(content, current_path)
                
            elif content.get("type") == "file":
                # Add file type descriptions based on extensions
                extension = content.get("extension", "").lower()
                if extension == ".json":
                    if "action_hierarchy" in name or "hierarchy" in name:
                        content["explanation"] = "Maps all PSC actions with their properties and DreamBot API calls."
                    elif "filter_types" in name:
                        content["explanation"] = "Documents all filter classes and operators."
                    elif "control_flow" in name:
                        content["explanation"] = "Defines logical structures and nesting rules."
                    elif "property_values" in name:
                        content["explanation"] = "Documents data types and formats."
                    elif "monster" in name:
                        content["explanation"] = "Catalog of non-member monsters with locations."
                    elif "equipment" in name:
                        content["explanation"] = "F2P equipment with stats and requirements."
                    elif "location" in name:
                        content["explanation"] = "Game locations with coordinates."
                    elif "ActionID_CategoryMap" in name:
                        content["explanation"] = "Maps action IDs to their appropriate categories."
                elif extension == ".py":
                    if "standardizer" in name:
                        content["explanation"] = "Main standardization tool for analyzing, standardizing, validating, and generating code."
                    elif "organize" in name:
                        content["explanation"] = "Script to organize raw PSC JSON files by category."
                    elif "hierarchy_updater" in name:
                        content["explanation"] = "Updates action hierarchy with missing actions from category map."
                    elif "sync_validator" in name:
                        content["explanation"] = "Validates action hierarchy against category map."
                elif extension == ".bat":
                    content["explanation"] = "Windows batch script for processing PSC files."
            
    return structure

def main():
    # Define directories to scan
    directories = [
        r"D:\RS_AI\pandemic-code\Dreambot Api Docs- Classes_Enums",
        r"D:\RS_AI\pandemic-code\enriched_code - Pandemics code",
        r"D:\RS_AI\pandemic-code\Pandemic coding docs - original - Not Cleaned",
        r"D:\RS_AI\pandemic-code\cleaned_docs - pandemic URL docs"
    ]
    
    # Generate high-level structure for these directories
    high_level_structure = {}
    for directory in directories:
        name = os.path.basename(directory)
        high_level_structure[name] = explain_directory_content(directory, include_files=False, max_depth=1)
        high_level_structure[name]["type"] = "directory"
        high_level_structure[name]["path"] = directory
    
    # Generate detailed structure for psc-dreambot-integration
    psc_integration_path = r"D:\RS_AI\pandemic-code\psc-dreambot-integration"
    psc_structure = explain_directory_content(psc_integration_path, include_files=True)
    
    # Add explanations to the structures
    add_directory_explanations(high_level_structure)
    psc_structure = add_directory_explanations({"psc-dreambot-integration": psc_structure})["psc-dreambot-integration"]
    
    # Create combined output
    output = {
        "project_root": "D:\\RS_AI\\pandemic-code",
        "high_level_directories": high_level_structure,
        "psc_dreambot_integration": psc_structure
    }
    
    # Write the output to a file
    with open("project_structure.json", "w") as f:
        json.dump(output, f, indent=2)
    
    print("Project structure has been written to project_structure.json")
    
    # Also create a text version for easier reading
    with open("project_structure.txt", "w") as f:
        f.write("PSC to DreamBot API Integration Project Structure\n")
        f.write("==============================================\n\n")
        
        # Write high-level directories
        f.write("High-Level Directories:\n")
        f.write("----------------------\n\n")
        for name, content in high_level_structure.items():
            f.write(f"{name} ({content['path']})\n")
            f.write(f"  Purpose: {content.get('explanation', 'No explanation available')}\n\n")
        
        # Write detailed psc-dreambot-integration structure
        f.write("\nPSC DreamBot Integration Directory:\n")
        f.write("--------------------------------\n\n")
        
        def write_structure(structure, f, indent=0):
            for name, content in structure.items():
                if name == "type" or name == "path" or name == "explanation":
                    continue
                
                indent_str = "  " * indent
                path = content.get("path", "") if isinstance(content, dict) else ""
                
                if isinstance(content, dict) and content.get("type") == "directory":
                    f.write(f"{indent_str}{name}/ ({path})\n")
                    if "explanation" in content:
                        f.write(f"{indent_str}  Purpose: {content['explanation']}\n")
                    write_structure(content, f, indent + 1)
                elif isinstance(content, dict):
                    f.write(f"{indent_str}{name} ({path})\n")
                    if "explanation" in content:
                        f.write(f"{indent_str}  Purpose: {content['explanation']}\n")
        
        write_structure(psc_structure, f)
    
    print("Project structure has also been written to project_structure.txt")

if __name__ == "__main__":
    main()